```{r message=FALSE warning=FALSE}
# Load libraries
library(yaml)
library(readr)
library(purrr)
library(data.table)
library(cmdstanr)
library(loo)
library(posterior)
library(bayesplot)
library(ggplot2)
library(devtools)
load_all()

theme_set(theme_bw())

# Load configurations
config <- read_yaml("../config/varselect.yaml")

# Load data
df <- read_rds(file.path("../data", "silver", config$data$fname))
```

```{r}
# Make Stan data
stan_data <- make_stan_data_varselect(df, config)
```

```{r}
config$s1$init_model
```


## Initial Poisson run
```{r}
m_pois_rhs <- cmdstan_model(file.path("../stan_models", "pois_horseshoe_s1.stan"), compile = TRUE)

fit_pois_rhs <- m_pois_rhs$sample(stan_data,
                                  seed = 0,
                                  iter_warmup = 500,
                                  iter_sampling = 1e3,
                                  chains = 2,
                                  parallel_chains = 2,
                                  max_treedepth = 13,
                                  refresh = 500)
```

```{r}
po <- summarise_draws(fit_pois_rhs$draws("beta"))
po$varname <- colnames(stan_data$X)

# Sort the coefficients by the posterior median
po <- setDT(po)
po[, vidx := as.numeric(stringr::str_remove_all(variable, "[beta|\\[|\\]]"))]
po[, std_eff_size := abs(median)]
setorderv(po, cols = "std_eff_size", order = -1)
po$varname <- factor(po$varname, levels = po$varname)

# Visualise posterior intervals
ggplot(po, aes(varname, median)) +
  geom_point() +
  geom_linerange(aes(ymin = q5, ymax = q95)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
# Helper functions
update_stan_data <- function(stan_data, po_sum, p) {
  X <- as.matrix(stan_data$X[, po_sum[1:p]$vidx])
  
  stan_data_update <- copy(stan_data)
  stan_data_update$X <- X
  stan_data_update$P <- ncol(X)
  
  return(stan_data_update)
}

fit_model <- function(stan_model, stan_data) {
  fit <- stan_model$sample(stan_data,
                           seed = 0,
                           iter_warmup = 5e2,
                           iter_sampling = 1e3,
                           chains = 2,
                           parallel_chains = 2,
                           max_treedepth = 13,
                           refresh = 0,
                           show_messages = FALSE,
                           show_exceptions = FALSE,
                           diagnostics = NULL)
  return(fit)
}
```

```{r}
# Compile the model
m_negb_normal <- cmdstan_model(file.path("../stan_models", "negb_normal_s1.stan"), compile = TRUE)

# Calculate LOO-ELPD for each variable
loo_elpd <- map_dbl(1:nrow(po), ~{
  stan_data_update <- update_stan_data(stan_data, po, .x)    # Update Stan data
  fit <- fit_model(m_negb_normal, stan_data_update)          # Fit the model
  suppressWarnings(loo(fit$draws("log_lik"))$estimates[1,1]) # Extract LOO-ELPD
}, .progress = TRUE)

# Create a data.table with the ELPD
dt_s1_varselect <- data.table(varname = po$varname,
                              loo_elpd = loo_elpd,
                              idx = 1:nrow(po))

# Plot the trajectory of the LOO-ELPD
ggplot(dt_s1_varselect, aes(idx, loo_elpd)) +
  geom_line(color = 2, linewidth = 0.7) +
  scale_x_continuous(breaks = seq(1,nrow(dt_s1_varselect)),
                     labels = dt_s1_varselect$varname) +
  labs(x = "Variable added to the model", y = expression(ELPD[loo])) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    panel.grid.minor.x = element_blank()
  )
```

```{r}
# Select the best model
selected_vars_s1 <- po[1:which.max(loo_elpd), varname]
```
### Refit the best model
```{r}
stan_data_update <- update_stan_data(stan_data, po, which.max(loo_elpd))
fit_negb_normal <- fit_model(m_negb_normal, stan_data_update)
```

```{r}
po_best <- summarise_draws(fit_negb_normal$draws("beta"))
po_best$varname <- colnames(stan_data_update$X)

ggplot(po_best, aes(varname, median)) +
  geom_point() +
  geom_linerange(aes(ymin = q5, ymax = q95)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
```{r}
s1.out <- list(
  selected_vars = selected_vars_s1,
  beta0 = fit_negb_normal$summary("beta0")$median,
  beta = fit_negb_normal$summary("beta")$median
)

stan_data <- make_stan_data_varselect(df, config, s1.out)
```

```{r}
# Compile Stan model
m_pois_rhs_s2 <- cmdstan_model(file.path("../stan_models", "pois_horseshoe_s2.stan"), compile = TRUE)

fit_pois_rhs_s2 <- m_pois_rhs_s2$sample(stan_data,
                                        seed = 0,
                                        iter_warmup = 500,
                                        iter_sampling = 1e3,
                                        chains = 2,
                                        parallel_chains = 2,
                                        max_treedepth = 13,
                                        refresh = 500)
```

```{r}
po <- summarise_draws(fit_pois_rhs_s2$draws("gamma"))
po$varname <- colnames(stan_data$X1)

# Sort the coefficients by the posterior median
po <- setDT(po)
po[, vidx := as.numeric(stringr::str_remove_all(variable, "[gamma|\\[|\\]]"))]
po[, std_eff_size := abs(median)]
setorderv(po, cols = "std_eff_size", order = -1)
po$varname <- factor(po$varname, levels = po$varname)

ggplot(po, aes(varname, median)) +
  geom_point() +
  geom_linerange(aes(ymin = q5, ymax = q95)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
```{r}
update_stan_data_s2 <- function(stan_data, po_sum, p) {
  X1 <- as.matrix(stan_data$X1[, po_sum[1:p]$vidx])
  
  stan_data_update <- copy(stan_data)
  stan_data_update$X1 <- X1
  stan_data_update$P1 <- ncol(X1)
  
  return(stan_data_update)
}
```

```{r}
m_negb_normal_s2 <- cmdstan_model(file.path("../stan_models", "negb_normal_s2.stan"), compile = TRUE)

loo_elpd <- map_dbl(1:nrow(po), ~{
  stan_data_update <- update_stan_data_s2(stan_data, po, .x)    # Update Stan data
  fit <- fit_model(m_negb_normal_s2, stan_data_update)          # Fit the model
  suppressWarnings(loo(fit$draws("log_lik"))$estimates[1,1]) # Extract LOO-ELPD
}, .progress = TRUE)

dt_s2_varselect <- data.table(varname = po$varname,
                              loo_elpd = loo_elpd,
                              idx = 1:nrow(po))

ggplot(dt_s2_varselect, aes(idx, loo_elpd)) +
  geom_line(color = 2, linewidth = 0.7) +
  scale_x_continuous(breaks = seq(1,nrow(dt_s2_varselect)),
                     labels = dt_s2_varselect$varname) +
  labs(x = "Variable added to the model", y = expression(ELPD[loo])) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    panel.grid.minor.x = element_blank()
  )
```
```{r}
selected_vars_s2 <- po[1:which.max(loo_elpd), varname]
```

## Fit the final model
```{r}
stan_data
```

